## PCB (Process Control Block)

- 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳을, 프로세스의 상태 정보를 저장하는 구조체임
- 프로세스의 상태 관리와 Context Switching을 위해서 필요함
- PCB는 운영체제가 프로세스를 표현한 것
- 프로세스가 생성될 때마다 고유의 PCB가 생서오디며, 프로세스가 완료되면 PCB는 제거됨

### PCB에 저장된 요소

![image](https://github.com/everyware-ie/CS/assets/88030920/a485f83f-803f-4105-b567-d4f2535eb1ee)

- Process ID : 프로세스 고유 ID
- Process State : 프로세스의 상태 (Create, Ready, Running 등등)
- Program Counter : 프로세스를 위해 실행될 다음 명령어의 주소
- Register : Accumulator, General Register 등을 포함하는 CPU Register의 값
- CPU Scheduling information : 우선순위, 최종 실행시간, CPU 점유 시간 등
- Memory management information : 해당 프로세스의 주소 공간 정보
- I/O Status : 프로세스에 할당된 입출력 장치 목록, 열린 파일 목록 등

<aside>
💡 레지스터란
연산에 필요한 데이터를 저장하고 빠른 속도로 접근할 수 있는 저장공간(메모리)
범용 / 세그먼트 / 포인터 / 인덱스 / 플래그로 나뉘어짐

- 범용 레지스터 : 연산 장치가 수행한  계산 결과의 임시 저장, 산술 및 논리 연산, 주소 색인 등에 사용 됨
- 세그먼트 레지스터 : 프로그램에 정의한 메모리상의 특정 영역으로 코드, 데이터, 스택 등을 포함
- 포인터 레지스터 : 프로그램 실행 과정에서 사용되는 주요 메모리 주소 값을 저장함
- 인덱스 레지스터 : 데이터를 복사할 때 출발지와 목적지 주소를 각각 가르킴
- 플래스 레지스터 : 산술 연산에 의해 자리 올림이나 자리 내림이 발생할 때 1이 됨

</aside>

## Context Switching은 무엇인지 설명해 주세요.

<aside>
💡 context란 프로그램의 카운터(PC), CPU 레지스터들의 값, 메모리 관리 상태 등을 포함한 프로세스의 상태를 뜻함

</aside>

- 현재 진행하고 있는 프로세스의 상태를 PCB에 저장하고 다음 진행할 프로세스의 정보를 PCB에서 읽어 적용하는 과정을 말함
- 쉽게 말해 저장하고 불러오는 과정

### Context Switching 필요한 이유

- CPU는 한번에 하나의 프로세스만 수행할 수 있음, 그러나 실생활에서 여러 개의 프로세스를 동시에 수행하려고 함
- CPU는 동시에 수행하는 것 처럼 보이게 하기 위해서 여러 개의 프로세스를 번갈아가며 수행함
- CPU가 프로세스를 바꿔가며 실행하기 위해 Context Switching이 필요함

### 과정

![image](https://github.com/everyware-ie/CS/assets/88030920/9824fdb8-ae1e-40f5-8e58-c19d618fc1f3)

1. P1 실행 중 인터럽트나 시스템 콜 발생
2. PCB1에 P1의 정보를 저장하고 PCB2에서 P2의 상태를 불러옴
3. P2 실행
4. P2 실행 중 인터럽트나 시스템 콜 발생
5. PCB2에 P2 정보 저장하고 PCB1의 상태를 불러옴
6. P1 실행

### 언제 발생하는가?

- CPU 스케줄링에 의해 할당된 작업시간이 끝나 timeout이 발생했을 때
- 프로세스의 작업이 끝났을 때
- 실행 중이던 프로세스가 입출력 요청을 할 때

## Overhead

- Context Switching에 걸린 시간과 메모리를 뜻함
- machine 마다 다르며, 일반적으로 매우 적은 시간이 소요됨

## 프로세스의 Context Switching이 발생하는 문제점과 원인이 무엇인가요?

스위칭을 하는 주체는 스케줄러라고 함

### 단점

- 프로세스를 올리고 내리는 작업 (MEM(RAM) ↔ HDD(하드디스크))은 많은 비용이 든다
- 스위칭 과정이 너무 잦으면 오버헤드가 발생하여 성능이 떨어짐

## Context Switching의 문제점에 대한 해결방안을 설명해 주세요.

### 해결 방안

멀티 스레드를 사용하면 단점을 보완할 수 있음

<aside>
💡 Thread란 프로세스 내에 존재하는 하나의 작업 흐름이다

</aside>

스레드는 프로세스와 달리 하나의 프로세스의 자원(stack 제외)을 공유하기 때문에 스위칭 비용을 줄일 수 있음

즉, 스레드에서는 code, data, stack, heap 중에서 stack만 교체하면되는 것임

![image](https://github.com/everyware-ie/CS/assets/88030920/3068c7e4-f3fa-4001-83af-b2b9ccb07557)

- 스레드간에는 프로세스의 주소/자원을 공유할 수 있음
- 스레드는 Thread ID, PC, register 집합, stack으로 구성됨
- 스레드 간에는 각자 독립적으로 작업을 수행해야 하기 때문에 각각 stack과 pc 레지스터를 할당받음

### 멀티 스레드 장점

- 프로세스의 자원을 스레드 마다 공유 → 비용 절감
- 스레드의 컨텍스트 스위칭은 캐시 메모리를 비울 필요가 없다 → 빠르다

### 단점

- 프로세스와 달리 data와 heap 영역을 공유 → 동기화 필요
- 멀티 프로세스와 달리, 하나의 스레드가 비정상적인 오류를 일으키면 다른 스레드도 영향을 받을 수 있음