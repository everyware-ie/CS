# 주소 변환
> [참고 - [OS] 메모리 가상화를 위한 주소 변환 (Address Translation) - OS 공부 9](https://icksw.tistory.com/143)

메모리를 가상화하는 방법

## 물리 주소와 논리 주소

### 물리주소

- **메모리 입장**에서 바라본 주소
- 실제 데이터가 저장되는 하드웨어 상의 주소

### 논리주소

- **CPU와 실행 중인 프로그램 입장에서** 바라본 주소
- 실행 중인 **프로그램 각각에게 부여**
- 0번지부터 시작

## 물리 주소와 논리 주소의 변환

아래와 같은 예시

- 논리 주소는 프로그램 각각이 0번지부터 부여받기 때문에
        
- 인터넷 브라우저(특정 프로그램1)의 0번지에 위치한 데이터, 게임(특정 프로그램2)의 0번지에 위치한 데이터에 대한 명령을 수행하기 위해서는

논리주소를 물리주소로 변환하는 과정이 필요하다.

# MMU(메모리 관리 장치)

****Memory Management Unit****의 약자로 논리 주소를 물리 주소로 변환해주는 하드웨어

- 가상 메모리의 논리 주소를 가지고 실제 데이터가 담겨 있는 곳에 접근하기 위해서는 빠른 주소 변환이 필요한데 이를 해주는 것
- 모든 변환은 MMU를 거친다.

# 동적 재배치 변환 방법

MMU는 어떻게 주소를 변환을 할까?

### 베이스 레지스터

말 그대로 **프로그램의 기준 주소**를 의미한다.

- 물리 주소 = 베이스 레지스터 + 논리 주소

MMU는 위 베이스 레지스터 값을 통해 논리주소를 물리주소로 변환한다. 

![image](https://github.com/everyware-ie/CS/assets/102847513/88c17397-5530-417f-a13b-8e0d50baabe2)

### 바운드 레지스터

가상 주소 공간의 크기를 나타낸다.

- 만약 아래처럼 메모리 범위를 초과하는 접근 요청이 들어온다면?? → 안되겠졍?ㅎ

![image](https://github.com/everyware-ie/CS/assets/102847513/3ff5f073-b0ee-41b8-a721-8a7a44407f9a)

따라서 메모리를 보호하기 위해 등장한 바운드 레지스터를 이용할 수 있다.

- 바운드 레지스터 → 실행 중인 프로그램의 최대 크기 저장
    - 베이스 레지스터 → 실행 중인 프로그램의 최소 물리 주소  저장
- 프로그램 영역을 침범할 수 있는 명령어의 실행을 막음
- 베이스 레지스터 값 ≤ 프로그램의 물리주소 범위 ≤ 베이스 레지스터 + 바운드 레지스터값

# OS 개입

메모리 가상화를 하드웨어만 사용해서는 할 수 없습니다. 

OS가 적절히 개입하여 메모리를 관리하고 메모리의 어떤 부분이 사용 중인지 어떻게 사용할 것인지를 제어해줘야 합니다.

- 가상 메모리의 base, limit를 구현하기 위해서 OS가 개입해야 하는 시점들이 존재

### 1. 프로세스가 생성될 때 프로세스의 주소 공간을 위해 실제 메모리에서 공간을 찾아야 합니다.

### 2. 프로세스가 종료되면 종료된 프로세스가 사용하던 메모리 공간을 다른 프로세스나 OS가 사용하기 위해서 반환해야 합니다.

### 3. OS는 context switch가 발생할 때 몇 가지 단계를 추가적으로 수행해야 합니다.

### 4. OS가 위에 설명한 대로 예외가 발생했을 때 호출할 핸들러나 함수를 제공해야 합니다.
