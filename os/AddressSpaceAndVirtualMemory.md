## 주소 공간

### 물리적 주소

메모리의 기능은 ‘데이터를 저장하는 컨테이너’ 그 이상 그 이하도 아니다. 단순히 크기가 굉장히 큰 배열로 생각해도 무방하다. 배열이기 때문에 인덱스 값을 가지는데, 이 인덱스 값을 ‘물리적 주소’라고 한다. 물리적 주소는 메모리 자체의 인덱스다.

실제 메모리 주소이며, 하드웨어에서 직접 접근 가능한 주소

시스템 전체적으로 공유되는 주소이며, 여러 프로세스가 공유 메모리 영역을 사용할 때 사용됨

프로세스가 물리 줏로 접근하려면, 물리 주소를 가르키고 있는 가상 주소를 물리 주소로 변환해야 함

### 논리적 주소

논리적 주소는 쉽게 말해서 CPU 입장에서 메모리 주소, 또는 프로그램 실행 중에 CPU가 생성하는 주소다. 따라서 가상 주소라고도 한다. 멀티 프로세싱 때문에 사용한다. 논리적 주소가 없다면 모든 프로세스가 물리적 주소에 직접 접근할 수 있게 된다. 이러면 아무런 안전 장치가 없기 때문에 프로세스끼리 주소 공간을 침범할 수 있는 문제가 발생한다.

### 프로세스 주소 공간

프로세스가 메모리를 할당 받으면 자신만의 방법으로 메모리를 관리하기 위해 이 공간들을 어떤 구조로 관리하는데, 이를 프로세스 주소 공간이라고 부른다

![image](https://github.com/everyware-ie/Algorithm/assets/88030920/ecabc608-eab2-4720-9460-3069424a5480)

- **Stack 영역**:
    - 함수의 호출과 관계되는 *지역 변수와 매개변수*가 저장되는 영역이다.
    - Stack 영역의 값은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다.
    - 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.
    - 재귀 함수가 너무 깊게 호출되거나 함수가 지역변수를 너무 많이 가지고 있어 stack 영역을 초과하면 stack overflow 에러가 발생한다.
- **Heap 영역**:
    - **런타임에 크기가 결정되는** 영역이다.
    - 사용자에 의해 공간이 동적으로 할당 및 해제된다.
    - 주로 참조형 데이터 (ex. 클래스) 등의 데이터가 할당된다.
    - 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.
- **Data 영역**:
    - 전역 변수나 Static 변수 등 프로그램이 사용할 수 있는 데이터를 저장하는 영역이다.
    - 어떤 프로그램에 전역/static 변수를 참조하는 코드가 존재한다면, 이 프로그램은 컴파일 된 후에 data 영역을 참조하게 된다.
    - 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.
    - 단, *초기화 되지 않은* 변수가 존재한다면, 이는 (그림에는 표현되지는 않았지만 BSS 영역에 저장된다.)
- **Text (Code) 영역**:
    - 프로그램이 실행될 수 있도록 CPU가 해석 가능한 기계어 코드가 저장되어 있는 공간으로, 프로그램이 수정되면 안 되므로 ReadOnly 상태로 저장 되어있다.

## 가상 메모리란?

가상 메모리(Virtual Memory)는 운영체제에서 실제 물리 메모리(RAM)보다 큰 주소 공간을 프로세스에 제공하기 위해 사용되는 기술

프로세스를 실행할 때 실행에 필요한 일부만 메모리에 로드하고 나머지는 디스크에 두는 것이다.

### 메모리 가상화가 생긴 이유

프로세스가 작업을 처리하기 위해 메모리를 할당 받아야함. 하지만, 작업을 처리하기 위한 메모리는 한정적임

즉, 컴퓨터의 실제 메모리 공간보다 프로세스가 처리해야할 메모리 공간이 더 많을 수 있다는 말임

→ **여러 개의 프로세스를 처리하거나, 메모리가 큰 프로세스를 처리하기위해 가상 메모리가 등장했다.**

가상 메모리는 시스템이 프로그램을 실행시키는데 최소한 얼마만큼의 메모리가 필요한가에 대한 접근 방식으로, 실행에 필요한 일부분만 메모리에 로드하고 나머지는 디스크에 두고서 필요할 때마다 교체하면서 쓰는 방식으로 구현됩니다.

### 가장 메모리의 장점

- 메인 메모리를 하드 디스크의 캐시로 처리하여 더 넓은 메모리 공간을 제공합니다. 즉, 임시 데이터를 하드 디스크 드라이브에 저장하고 필요에 따라 기본 메모리로 가져올 수도 있습니다.
- 메모리 크기의 제약으로부터 자유로워졌고 사용자 프로그램이 실행에 필요한 최소 크기의 메모리만 올라가져 있기 때문에 더 많은 프로그램을 동시 수행 가능해졌습니다.
- 추가 권한 비트를 사용하여 각 프로세스에 메모리에 대한 제한된 액세스 권한을 부여하여 메모리를 보호합니다. OS는 권한 비트를 확인하여 한 프로세스가 다른 프로세스의 메모리 공간을 손상시키지 않도록 할 수 있습니다.

### 가상 주소

- 프로세스가 참조하는 주소
- 프로세스마다 독립적으로 할당 되며, 프로세스는 자신만의 가상 주소 공간을 가지고 있다고 생각함
- 논리적인 주소, 운영체제는 프로세스에게 연속된 가상 주소 공간을 제공하고, 이를 필요한 크기의 물리 메모리 페이지로 매핑함. 이 작업으로 메모리 공간 낭비를 최소화할 수 있음
- 만약 프로세스의 모든 데이터를 물리 주소로 접근한다면 여러 개의 프로세스들이 실행되면서 물리 주소를 접근해서 데이터를 수정하고, 민감 데이터를 쉽게 읽어온다면 오류가 발생함
- 프로세스마다 다른 가상 주소를 사용하면 같은 물리 주소 위치를 가르키고 있을 수 있지만, 읽고 쓰고할 수 있는 공간은 가상 주소 공간에서만 제한되므로 실제 물리 주소의 데이터들이 수정되거나, 프로세스들이 동시에 접근해서 충돌하는 일은 없을 것임

### **가상 메모리 동작 원리**

프로세스는 생성될 때 메모리를 일정하게 할당 받는다. 그런데 프로세스가 모든 메모리 공간을 사용하는 것이 아니라, 처리해야할 데이터나 작업에 따라 공간을 모두 사용할 수도 있고, 공간이 남을 수도 있다. 이때, 프로세스가 차지하는 실제 메모리 공간만 물리 메모리(RAM)에 넣고, 이 물리 메모리를 접근할 수 있는 가상 주소를 프로세스의 메모리에 저장한다.

그 이후, 프로세스가 작업을 처리하기 위해 CPU를 호출하고, CPU는 작업을 처리하기 위해 특정 데이터를 조회할 수 있다. 이때, 특정 데이터가 물리 메모리(RAM) 어디에 있는지는 데이터의 가상 주소를 통해 알 수 있다. **프로세스는 CPU에게 작업을 요청할 때 데이터의 가상 주소를 넘긴다.**

가상 주소는 실제 물리 주소와 이어져 있지만, 가상 주소가 차지하는 가상 메모리 공간은 아주 작다. 실제 데이터는 큰 물리 공간을 차지하고 있겠지만, **가상 메모리로 인해 아주 작은 메모리 공간을 차지하면서 실제 메모리와 연결**되어있는 것이다.

CPU는 작업을 처리하기 위해 실제 데이터가 어디에 있는지 물리 주소 위치를 알아야하는데, 이때 가상 주소를 물리 주소로 변환하는 작업을 거친다. 가상 주소를 물리 주소로 변환하는 작업을 하는 시스템은 MMU 이다.

![image](https://github.com/everyware-ie/Algorithm/assets/88030920/b391297e-c9c7-4ecc-a142-3abaee86262f)

### **MMU(Memory Management Unit)**

**MMU는 가상 주소를 물리 주소로 변환**하고, 메모리를 보호하는 기능을 수행한다.

MMU를 사용하게 되면, CPU는 각 물리 메모리에 접근하기 이전에 메모리 주소 변환 작업을 거친다.

MMU는 굉장히 빈번하게 작업을 처리해야 하기 때문에, 소프트웨어 코드만으로는 이 작업을 수행하기 벅차다. 그래서 메모리 관리 작업을 하는 특수한 하드웨어를 따로 컴퓨터에 설치해야 한다. (실제로는 작은 칩을 컴퓨터에 꽂아서 사용한다)

MMU가 메모리를 일일이 가상 주소에서 물리 주소로 변환하게 되면, 작업 부하가 높아질 수 있다. 그래서 MMU는 실제 물리 메모리 공간을 여러 페이지 단위로 나눠서, 각 **페이지 단위로 데이터를 처리**한다.

### 가상 메모리 계층 구조

1. 물리 메모리
2. 가상 메모리
3. 페이지 파일 : 디스크 공간으로, 물리적 메모리가 부족할 때 데이터를 임시로 저장함
4. 페이지 테이블 : 가상 주소 공간과 물리 주소 공간 간의 매핑 정보 유지, 프로세스 각 페이지에 대한 물리 주소를 찾기 위해 사용
5. MMU