# Redis

![Untitled](https://melodic-droplet-c1f.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F3c793912-0294-456e-ba59-f7da91aea06d%2F10f26a66-70ba-4152-a8a6-c926d8b6e277%2FUntitled.png?table=block&id=0494e498-d8c4-4182-8cfb-ad93ac55cb88&spaceId=3c793912-0294-456e-ba59-f7da91aea06d&width=860&userId=&cache=v2)

## 레디스란?

Redis는 Remote Dictionary Server의 약자로 Key-Value 쌍의 해시 맵과 같은 구조를 가진 비관계형(NoSQL) 데이터베이스 관리 시스템(DBMS).

Redis는 모든 데이터를 메모리에 저장하고 조회함. 즉 인-메모리(in-memory) 데이터베이스.

key, value 구조이기 때문에 별도의 쿼리문이 필요하지 않고, 인-메모리에 저장되기 때문에 상당히 빠른 속도로 처리할 수 있음.

## Redis의 특징 및 장단점

1. 성능
    
    모든 Redis 데이터는 메모리에 저장되어 대기 시간을 낮추고 처리량을 높임
    
    평균적으로 읽기 및 쓰기의 작업 속도가 1ms로 디스크 기반 데이터베이스보다 빠름
    
2. 유연한 데이터 구조
    
    Redis의 데이터는 String, List, Set, Hash, Sorted Set, Bitmap, JSON 등 다양한 데이터 타입을 지원함. 따라서, 애플리케이션의 요구 사항에 알맞은 다양한 데이터 타입을 활용할 수 있음
    
3. 개발 용이성
    
    Redis는 쿼리문이 필요로 하지 않으며, 단순한 명령 구조로 데이터의 저장, 조회 등이 가능
    
    또한, Java, Python, C, C++, C#, JavaScript, PHP, Node.js, Rubyt 등 다수의 언어 지원
    
4. 영속성
    
    Redis는 영속성을 보장하기 위해 데이터를 디스크에 저장할 수 있음. 서버에 치명적인 문제가 발생하더라도 디스크에 저장된 데이터를 통해 복구가 가능
    
5. 싱글 스레드 방식
    
    Redis는 싱글 스레드 방식을 사용하여 한 번에 하나의 명령어만을 처리함. 따라서 연산을 원자적으로 처리하여 Race Condition(경쟁 상태)가 거의 발생하지 않음.
    
    하지만, 멀티 스레드를 지원하지 않기 때문에 시간 복잡도가 O(n)인 명령어의 사용은 주의해서 사용해야 함
    

## 다양한 데이터 구조

Redis에 모든 데이터를 메모리에 저장하는 빠른 DB가 다라고 생각할지도 모르겠지만 레디스의 다른 인메모리 디비들과의 가장 큰 차이점은 레디스의 다양한 자료구조임.

## Redis 영속성

> 레디스가 메모리에만 데이터를 저장한다면, 레디스가 다운되어 재실행될 때 데이터를 잃어버릴 것임. 다행히도 레디스는 데이터를 디스크에도 저장하여 영속성을 보장. 그렇다면 레디스가 영속성 보장을 위해 제공하는 두 가지 방법에 대해 알아보자.
> 
- 영속성
    
    간단히 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 데이터의 특성
    

### RDB(Redis Database)

RDB는 특정 시점의 레디스 데이터(스냅샷)를 나타내는 여러 개의 데이터 파일을 생성하는 방식

### AOF(Append Only File)

AOF는 각 쓰기 명령을 로그로 간주하고 log 파일에 저장함. 해당 로그 파일은 append-only 모드로 쓰여짐. 레디스가 다시 시작되면 AOF 로그에 저장된 명령을 재실행하여 기존 데이터를 복구함.

→ 따라서 레디스는 RDB 또는 AOF를 통해 보관된 데이터를 클라우드 서비스와 같은 다른 위치에 백업할 수 있음. 이 데이터를 복사하여 지정된 디렉터리에 넣은 다음 레디스를 다시 시작하면 레디스가 자동으로 데이터를 다시 저장함.

RDB와 AOF를 동시에 사용하는 경우 레디스가 다시 시작될 때 AOF 데이터가 더 완전하다고 판단하여 AOF를 사용해 데이터를 다시 저장

### RDB 특징

- RDB 방식은 레디스의 읽기/쓰기에 거의 영향을 미치지 않음. 왜냐하면 main 프로세스는 child 프로세스를 생성만 하고 RDB 명령 실행은 child 프로세스를 통해 수행할 수 있음
- RDB 데이터 파일을 기반으로 레디스를 복구하고 재시작하는게 AOF 방식보다 빠름
- 가능한 적은 양의 데이터 손실로 레디스를 복구하려 한다면 RDB 방식은 AOF보다 좋지 않음. 일반적으로 RDB 데이터 스냅샷 파일은 5분 이상 주기로 생성되며 이 때 레디스가 다운된다면 해당 주기 만큼의 데이터를 손실하게 됨
- 레디스 데이터가 너무 큰 경우 child process를 fork 하는 과정에서 길게는 수 초의 서비스 중단이 발생할 수 있음

### AOF 특징

- AOF는 RDB방식보다 데이터 손실을 더 적게 가져갈 수 있음. 일반적으로 백그라운드 스레드를 통해 1초마다 fsync 명령을 수행함
    - fsync: 쓰는 순간 파일에 저장되는 명령어. 주기에 따라 쓰기 명령에 영향을 줄 수 있음.
    - always: 매 쓰기 명령이 실행될 때마다 fsync를 실행. 성능이 매우 저하
    - everysec: 1초 동안의 데이터를 모아서 별도의 쓰레드가 fsync를 실행. 일반적으로 성능에 거의 영향 X
    - no: 레디스가 fsync를 실행하지 않음. OS가 주기적(30초)으로 fsync를 실행해서 데이터를 디스크에 저장. 성능은 좋을 수 있지만 데이터 유실의 가능성이 있음
    - AOF는 특정 시점에 rewrite를 실행하여 현재 메모리 정보를 로그파일로 재기록하는데, 이를 통해 로그파일의 사이즈를 줄일 수 있음
        - rewrite는 fork를 통해 자식 프로세스에서 수행
    - AOF 로그 파일은 읽기 쉬운 방식으로 제공됨. 만약 누군가 flushall 명령으로 데이터를 날려버렸다면 AOF 파일에서 flushall 만을 제거하여 복구할 수 있음
        - 단, 복구를 원하는 시점 이후에 rewirte가 실행된 적이 있다면 복구 불가
    - 동일한 데이터의 경우 AOF 로그 파일은 일반적으로 RDB 파일보다 큼

### Redis의 인기 있는 사용 사례

- 데이터 캐싱
- 세션 저장소
- Pub/Sub 메시징 시스템